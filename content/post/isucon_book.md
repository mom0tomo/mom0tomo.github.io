---
title: 『達人が教えるWebパフォーマンスチューニング』を読んだ（①基礎的な負荷試験編）
date: 2023-05-26T09:29:20+09:00
draft: false
tags: ["Book", "SRE"]
images: ["images/articles/avatar.png"]
description: "まだ読み切っていないので、追記していく予定。クラシックな構成であるという感想もあったが、わかりやすくシンプルな解説をしている本書の構成を良いと思った。

しかし、自分は正規の教育を受けたことがなかったので、いわゆるクラシックな構成を前提にポイントを絞ったシンプルな解説をしている本書の構成が良かった。
"
---

まだ読み切っていないので、追記していく予定。

## 『達人が教えるWebパフォーマンスチューニング』概要

章立ては以下の通り。

- Chapter 1　チューニングの基礎知識
- Chapter 2　モニタリング
- Chapter 3　基礎的な負荷試験
- Chapter 4　シナリオを持った負荷試験
- Chapter 5　データベースのチューニング
- Chapter 6　リバースプロキシの利用
- Chapter 7　キャッシュの活用
- Chapter 8　押さえておきたい高速化手法
- Chapter 9　OSの基礎知識とチューニング

概要については下記のポストにまとめられている。

- [【書評】「達人が教えるWebパフォーマンスチューニング」 Webアプリケーションのパフォーマンスを出すための指針を教えてくれる本](https://dev.classmethod.jp/articles/220609_book_web_performance_tunning/)
- [「達人が教える Webパフォーマンスチューニング ~ISUCONから学ぶ高速化の実践」レビュー](https://qiita.com/chibiegg/items/b82cfc4bbd33e14890a7)

2章までは基礎知識・理論で、3章からは実践的な内容になっている。
[理論の部分についての補足・批判が入った読書メモを@ymotongpooさんがまとめてくれていて](https://zenn.dev/ymotongpoo/articles/7bb8e269650b38)、こちらも参考になる。

感想の中に、全体的にクラシックな構成（サーバーにSSHしてLinuxコマンドを叩くなど）であるというものがあった。確かにそうだと思う。学校など教育機関で学んだ人は、クラシックな構成は触り慣れているので、コンテナなどモダンな環境の実践から入りたいかもしれない。

しかし、自分は正規の教育を受けたことがなかったので、いわゆるクラシックな構成を前提にポイントを絞ったシンプルな解説をしている本書の構成が良かった。

仕事でもまだオンプレサーバーを触る機会はあるし、自分の場合こういったパフォーマンスモニタリングは苦しみがら実践で覚えるしかなかったので（知識にムラも出るし作業が危険だし効率が悪い）、本書のようにハンズオン環境を用意して解説してくれる本はありがたい。コンテナにはコンテナの考え方があり、クラシックな環境とは覚えることが異なるが、コンテナ時代にもクラシックな環境で学んだ考え方は役に立つと感じている。そして、学ぶときの構成はできるだけシンプルな方が初学者にはわかりやすくてよい。

3章から著者の一人である @catatsuyさんの[private-isu](https://github.com/catatsuy/private-isu)を利用して実際にパフォーマンスチューニングを手を動かしながら学ぶ。このうち、自分が参考になったと思うことをメモしていく。

## Chapter 3　基礎的な負荷試験　読書メモ

改善していく順序は以下の通り。

### 1. ログを整備する

- Nginxの設定を変更してアクセスログを見やすい形に整形する（JSONにする）
  - ログをパースするツールを入れる。alpを使っているが、LTSV形式にしてlltsvでパースするのもよさそう
  - ログをローテーションする
    - 定時でログをローテーションする必要はないので、随時必要なときにローテーションする。nginx reloadするか、nginx -s repoenでmasterプロセスにシグナルを送信する

### 2. ベンチマーカーを利用した負荷試験を実行する

- abコマンドを使う
  - 最初は直列で実行する
  - ベンチマーカーの結果とアクセスログを比較してだいたい同じになることを確認する
    - 大きく異なる場合はNgixを実行しているサーバーとベンチマーカーを実行しているホストとの間のネットワークに問題がある可能性がある。Nginxを実行しているサーバー内でベンチマーカーを実行してみる

### 3. CPU利用率の高いプロセスを確認してボトルネックを探す

- topコマンドを使う
  - ホスト全体で使えるCPUは何コアか？
  - 過大にCPUを使っているプロセスはないか？

チューニングを行うたびに、再度負荷試験を実行して結果を確認する。また、ベンチマーカーの並列度をあげて負荷試験を再度実行する。

### アクセスログの注目すべきポイント

Nginxのログのうち、パフォーマンス観点から注目すべきものがいくつかある。
パフォーマンスを改善するとわかりやすく変化数値としては、レイテンシとスループットの2つがある。

- Time per requests（レスポンスタイム・レイテンシ）
  - 1リクエストの処理にかかる時間
- Request per seconds（スループット）
  - 1秒間に処理できたリクエスト数

ツールを使って負荷をかけベンチマークを取る際、まずレイテンシに注目するとわかりやすい。しかし、レイテンシは削減していくと利用者の体幹に変化がなくなる（10ms以下の違いは利用者にはわからない）。
そこで、スループットが実運用において重要な指標となる。多数のリクエストが発生した場合に利用者の体感に影響するためである。

レイテンシとスループットは反比例の関係になるが、レイテンシの短縮には限界があり、それだけではスループットは向上しない。スループットの向上のためには、レイテンシの短縮と同時に、他の処理の最適化が必要になる。

（感想: レイテンシとスループットってなぜか覚えられず（英語と日本語がつながらない）、図で覚えている。）

![Latency, Bandwidth, Throughput and Response Time](/images/articles/latency-bandwidth-throughput-and-response-time.png)

ref: [Latency, Bandwidth, Throughput and Response Time](https://www.perfmatrix.com/latency-bandwidth-throughput-and-response-time/)

利用したコマンド:

```bash
# JSON形式に変換したログをalpで整形する
$ tail -n 10 /var/log/nginx/access.log.json | alp json -o count,method,uri,min,avg,max

シグナルを送り、ログファイルを再オープンする（ログファイルがローテーションされたことを通知する）
$ nginx -s reopen
```

### topコマンドの見方と確認時の注意

```bash
$ top
top - 09:58:51 up 23 min,  2 users,  load average: 0.27, 0.
Tasks: 109 total,   1 running, 108 sleeping,   0 stopped,   0 zombie
%Cpu(s): 50.7 us,  0.8 sy,  0.0 ni, 48.3 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   3843.5 total,   2597.1 free,    631.6 used,    614.8 buff/cache
MiB Swap:      0.0 total,      0.0 free,      0.0 used.   2983.0 avail Mem

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    622 mysql     20   0 1784476 419584  35872 S  98.0  10.7   2:18.19 mysqld
    450 isucon    20   0 1089196  19504   8132 S   4.7   0.5   0:05.41 app
    528 www-data  20   0   55836   5512   3600 S   0.3   0.1   0:00.03 nginx
...
```

- `/proc/cpu` を確認すると、ホスト全体で使えるCPUが何コアかわかる。EC2の場合はインスタンスタイプから逆引きできる。
- `%Cpu(s)` からそのうちどのくらいが使用されているかわかる。2コアの場合、50%だと1コアが使われていることになる。
  - ここでの %表示は1コアあたりの使用率ではなく、全体の使用率に対する割合であることに注意する
- Webアプリケーションのプロセス（app）がどのくらいCPUを使っているかわかる。
- Webサーバーのプロセス（nginx）がどのくらいCPUを使っているかわかる。
- mysqldが異常にCPUを使用しており、ボトルネックになっていることがわかる。


### MySQLがボトルネックだった場合の対応

まずスロークエリログを出力する。
MySQLではデフォルトでスロークエリログが出力されないので自分で設定を変更する必要がある。
また、パフォーマンスチューニングの際には、スロークエリログにすべてのクエリを出力するようにしておくことで、遅くはないが大量に発行されているクエリなど問題のあるクエリを特定できる。

mysqldumpslowコマンドなど、集計ツールを使ってスロークエリログを解析する。
mysqltunerコマンドはログ中の実行時間の合計が長いクエリから順に表示してくれる。すべてのクエリのログを出力しておくことで、一度の実行時間は短くても、大量に発行されていてリソースを消費しているクエリを発見できる。

クエリと問題になっているテーブルが特定できたら、`SHOW CREATE TABLE xxx` を実行してテーブルのスキーマを確認する。
EXPLAINコマンドと問題のクエリを使って、どんなクエリが発行されているのかクエリの実行計画を確認する。
インデックスが貼られていない場合は、インデックスを貼る。

チューニングしたら、スロークエリログのファイルの古い方を削除またはrenameして、チューニング後のパフォーマンス測定時のログと分離する。
MySQLではログファイルを削除したりrenameした場合、mysqladmin flush-logsを実行する必要がある。

再度負荷試験を実行する。
設定を1つ変更したら必ず負荷試験を行い、設定の効果を確認する。

（感想: この辺りのDBのチューニングをあまりやったことがないので、苦手意識があったが、意外ととっつきやすいと思った。）

### ベンチマーカーの並列度を上げて負荷試験を実行する

並列度を上げて負荷試験を実行した際に、変化したものと変化しなかったものを確認する。
並列度に比例して悪化したものがある場合、そこにボトルネックがある。

本書のサンプルではレスポンスタイムが悪化していた。並列にリクエストを送ると比例してレスポンスタイムが悪化しているため、単一のリクエストの場合ですでにサーバーの処理能力が飽和していることがわかる。

dstatコマンドを利用して時系列でCPU利用率を表示し、CPUを有効に利用できているか確認する（今回は2コアなので、idleを確認して2つのCPUコアを有効に利用できているか見る）。

CPUのidleが50%ほどある場合、1コアが使われていないことになる。この場合、サーバーの設定を変えることでCPUをもっと有効に利用できる可能性がある。複数のCPUコアを有効に利用するためには、複数のプロセスを並列に実行するようサーバーを設定する。

本書ではRubyのアプリケーションでunicornを使っているが、unicornは1プロセスで1リクエストを処理するため、初期設定のままだと複数のCPUコアを有効に利用できない。そこで、unicornのワーカープロセスを複数起動するよう設定を変更する。

利用したコマンド:

```bash
# CPU負荷をコアごとに表示する
# usr … ユーザ空間で使われたCPU使用時間の割合
# sys … システム空間で使われたCPU仕様時間の割合
# idl … アイドル状態のCPU時間の割合
$ dstat --cpu
```

***

このまま書いていくと長くなるので、分けることにする。
