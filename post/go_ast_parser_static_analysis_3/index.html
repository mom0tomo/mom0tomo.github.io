<!doctype html><html lang=ja><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Goの標準パッケージではじめる静的解析入門③実践編"><meta property="og:description" content="Go言語では、標準パッケージであるgoパッケージが字句解析や構文解析を行う機能を提供しています。go/astやgo/parserを使って構文解析のはじめの一歩を踏み出してみます。今回は静的解析を使って実践的な処理を行ってみます。"><meta property="og:type" content="article"><meta property="og:url" content="https://mom0tomo.github.io/post/go_ast_parser_static_analysis_3/"><meta property="og:image" content="https://mom0tomo.github.io/images/articles/avatar.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-03-24T19:32:28+09:00"><meta property="article:modified_time" content="2019-03-24T19:32:28+09:00"><meta property="og:site_name" content="mom0tomo.github.io"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mom0tomo.github.io/images/articles/avatar.png"><meta name=twitter:title content="Goの標準パッケージではじめる静的解析入門③実践編"><meta name=twitter:description content="Go言語では、標準パッケージであるgoパッケージが字句解析や構文解析を行う機能を提供しています。go/astやgo/parserを使って構文解析のはじめの一歩を踏み出してみます。今回は静的解析を使って実践的な処理を行ってみます。"><meta name=twitter:site content="@https://twitter.com/mom0tomo"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-104531981-1','auto'),ga('send','pageview'))</script><meta name=description content="Go言語では、標準パッケージであるgoパッケージが字句解析や構文解析を行う機能を提供しています。go/astやgo/parserを使って構文解析のはじめの一歩を踏み出してみます。今回は静的解析を使って実践的な処理を行ってみます。"><meta name=generator content="Hugo 0.81.0"><title>Goの標準パッケージではじめる静的解析入門③実践編 &#183; mom0tomo</title><link rel="shortcut icon" href=https://mom0tomo.github.io/images/favicon.ico><link rel=stylesheet href=https://mom0tomo.github.io/css/style.css><link rel=stylesheet href=https://mom0tomo.github.io/css/highlight.css><link rel=stylesheet href=https://mom0tomo.github.io/css/monosocialiconsfont.css><link href=https://mom0tomo.github.io/index.xml rel=alternate type=application/rss+xml title=mom0tomo><link rel=stylesheet href=https://mom0tomo.github.io/css/custom.css><script type=text/javascript src=http://s.hatena.ne.jp/js/HatenaStar.js></script><script type=text/javascript>Hatena.Star.Token='439b2988ff9e3560541978cfebab857d59ac4047',Hatena.Star.SiteConfig={entryNodes:{'section#wrapper':{uri:'div.posted a',title:'h1',container:'span.hatena-star'}}}</script></head><body><nav class=main-nav><a href=https://mom0tomo.github.io/><span class=arrow>← </span>Home</a>
<a href="post/go_ast_parser_static_analysis_3/ about">about</a>
<a href="post/go_ast_parser_static_analysis_3/ archive">archive</a>
<a href="post/go_ast_parser_static_analysis_3/ tags">tags</a>
<a href=https://mom0tomo.github.io/index.xml class=symbol style=font-size:15px></a></nav><section id=wrapper><article class=post><header><h1>Goの標準パッケージではじめる静的解析入門③実践編</h1><div class=posted style=display:none><a href=https://mom0tomo.github.io/post/go_ast_parser_static_analysis_3/>Goの標準パッケージではじめる静的解析入門③実践編</a></div><h2 class=headline>Mar 24, 2019 19:32
· 2027 words
· 5 minutes read
<span class=tags><a href=https://mom0tomo.github.io/tags/go>Go</a>
<a href=https://mom0tomo.github.io/tags/%E9%9D%99%E7%9A%84%E8%A7%A3%E6%9E%90>静的解析</a></span></h2></header><div id=toc><nav id=TableOfContents><ul><li><a href=#はじめに>はじめに</a></li><li><a href=#ファイルを準備する>ファイルを準備する</a></li><li><a href=#抽象構文木astを探索して結果を出力する>抽象構文木(AST)を探索して結果を出力する</a></li><li><a href=#抽象構文木astのソースコード内の位置情報を取得する>抽象構文木(AST)のソースコード内の位置情報を取得する</a></li><li><a href=#抽象構文木astを再帰的にトラバースする>抽象構文木(AST)を再帰的にトラバースする</a></li><li><a href=#おわりに>おわりに</a></li></ul></nav></div><section id=post-body><h2 id=はじめに>はじめに</h2><p><a href=https://mom0tomo.github.io/post/go_ast_parser_static_analysis_2>前回</a>は字句解析と構文解析を実際にやってみました。</p><p>今回は取得した抽象構文木(AST)を使って実践的な処理を行ってみます。</p><hr><h2 id=ファイルを準備する>ファイルを準備する</h2><p>解析するためのサンプルファイル(example.go)と、解析処理を書くファイル(main.go)を準備します。</p><p>なお、処理を見やすくするためにエラーを潰しているところがあります。</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>$ mkdir example
$ touch example/example.go 

$ touch main.go
</code></pre></div><p>今回はexample.goの内容を以下のようにします。</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>package</span> example

<span style=color:#6ab825;font-weight:700>import</span> (
  <span style=color:#ed9d13>&#34;fmt&#34;</span>
  <span style=color:#ed9d13>&#34;time&#34;</span>
)

<span style=color:#6ab825;font-weight:700>func</span> <span style=color:#447fcf>example</span>() {
  fmt.<span style=color:#447fcf>Println</span>(<span style=color:#ed9d13>&#34;Now :&#34;</span>, time.<span style=color:#447fcf>Now</span>())
}
</code></pre></div><p>またmain.goには、いったん抽象構文木(AST)を取得する処理まで書いておきます。</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>package</span> main

<span style=color:#6ab825;font-weight:700>import</span> (
  <span style=color:#ed9d13>&#34;fmt&#34;</span>
  <span style=color:#ed9d13>&#34;go/parser&#34;</span>
  <span style=color:#ed9d13>&#34;go/token&#34;</span>
)

<span style=color:#6ab825;font-weight:700>func</span> <span style=color:#447fcf>main</span>() {
  fset := token.<span style=color:#447fcf>NewFileSet</span>()
  <span style=color:#999;font-style:italic>// ファイルをパースしてを抽象構文木(AST)に変換する
</span><span style=color:#999;font-style:italic></span>  f, _ := parser.<span style=color:#447fcf>ParseFile</span>(fset, <span style=color:#ed9d13>&#34;./example/example.go&#34;</span>, <span style=color:#6ab825;font-weight:700>nil</span>, parser.<span style=color:#447fcf>Mode</span>(<span style=color:#3677a9>0</span>)))
}
</code></pre></div><p><a href=https://godoc.org/go/parser#example-ParseFile>parser.Mode</a>というのはソースコードのパースしたい部分を指定したり、エラーを報告するかどうか選択するするためのものです。</p><p>必要な処理だけあらかじめ指定しておけば、パース処理が無駄なくなりますね。</p><p>下記の値が指定できます。</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>const</span> (
    PackageClauseOnly Mode             = <span style=color:#3677a9>1</span> &lt;&lt; <span style=color:#6ab825;font-weight:700>iota</span> <span style=color:#999;font-style:italic>// stop parsing after package clause
</span><span style=color:#999;font-style:italic></span>    ImportsOnly                                    <span style=color:#999;font-style:italic>// stop parsing after import declarations
</span><span style=color:#999;font-style:italic></span>    ParseComments                                  <span style=color:#999;font-style:italic>// parse comments and add them to AST
</span><span style=color:#999;font-style:italic></span>    Trace                                          <span style=color:#999;font-style:italic>// print a trace of parsed productions
</span><span style=color:#999;font-style:italic></span>    DeclarationErrors                              <span style=color:#999;font-style:italic>// report declaration errors
</span><span style=color:#999;font-style:italic></span>    SpuriousErrors                                 <span style=color:#999;font-style:italic>// same as AllErrors, for backward-compatibility
</span><span style=color:#999;font-style:italic></span>    AllErrors         = SpuriousErrors             <span style=color:#999;font-style:italic>// report all errors (not just the first 10 on different lines)
</span><span style=color:#999;font-style:italic></span>)
</code></pre></div><p>今回のように、とりあえず何も指定せず全てパースしたいときは<code>parser.Mode(0))</code>またはただの 0としておきます。</p><h2 id=抽象構文木astを探索して結果を出力する>抽象構文木(AST)を探索して結果を出力する</h2><p>前回の構文解析で取得した抽象構文木(AST)を使い、ノードを探索して結果を出力してみます。</p><p>ファイル内のコメントだけ抜き出したり、関数名だけ調べたりできるのは便利でうれしいですよね！</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>func</span> <span style=color:#447fcf>main</span>() {
  fset := token.<span style=color:#447fcf>NewFileSet</span>()
  <span style=color:#999;font-style:italic>// package名とimportされているパッケージが取得できれば良いのでImportsOnlyモードにする
</span><span style=color:#999;font-style:italic></span>  f, _ := parser.<span style=color:#447fcf>ParseFile</span>(fset, <span style=color:#ed9d13>&#34;./example/example.go&#34;</span>, <span style=color:#6ab825;font-weight:700>nil</span>, parser.ImportsOnly)

  <span style=color:#999;font-style:italic>// package名を出力する
</span><span style=color:#999;font-style:italic></span>  fmt.<span style=color:#447fcf>Println</span>(f.Name)

  <span style=color:#999;font-style:italic>// importされているパッケージを出力する
</span><span style=color:#999;font-style:italic></span>  <span style=color:#6ab825;font-weight:700>for</span> _, s := <span style=color:#6ab825;font-weight:700>range</span> f.Imports {
    fmt.<span style=color:#447fcf>Println</span>(s.Path.Value)
  }
}
</code></pre></div><p>出力結果は以下のようになります。</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>&#34;fmt&#34;
&#34;time&#34;
</code></pre></div><p>ほかにもCommentなどいろいろ取得できます。</p><p>取得できるものの一覧は、<a href=https://godoc.org/go/ast#File>ast/File</a>に書いてあります。</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>type</span> File <span style=color:#6ab825;font-weight:700>struct</span> {
    Doc        *CommentGroup   <span style=color:#999;font-style:italic>// associated documentation; or nil
</span><span style=color:#999;font-style:italic></span>    Package    token.Pos       <span style=color:#999;font-style:italic>// position of &#34;package&#34; keyword
</span><span style=color:#999;font-style:italic></span>    Name       *Ident          <span style=color:#999;font-style:italic>// package name
</span><span style=color:#999;font-style:italic></span>    Decls      []Decl          <span style=color:#999;font-style:italic>// top-level declarations; or nil
</span><span style=color:#999;font-style:italic></span>    Scope      *Scope          <span style=color:#999;font-style:italic>// package scope (this file only)
</span><span style=color:#999;font-style:italic></span>    Imports    []*ImportSpec   <span style=color:#999;font-style:italic>// imports in this file
</span><span style=color:#999;font-style:italic></span>    Unresolved []*Ident        <span style=color:#999;font-style:italic>// unresolved identifiers in this file
</span><span style=color:#999;font-style:italic></span>    Comments   []*CommentGroup <span style=color:#999;font-style:italic>// list of all comments in the source file
</span><span style=color:#999;font-style:italic></span>}
</code></pre></div><hr><h2 id=抽象構文木astのソースコード内の位置情報を取得する>抽象構文木(AST)のソースコード内の位置情報を取得する</h2><p>ファイル名や行番号など、ソースコード内の位置情報を取得して使いたいことがあります。</p><p>先ほどの解析結果に行番号の情報を追加して出力してみます。</p><p>ソースコード内のノードの位置情報を取得するには、<a href=https://godoc.org/go/token#Pos>token/Pos</a>を使います。</p><p>また今回はノードの位置情報だけでなくファイルとその行数なども出力したいので、より詳細な情報を出力できる<a href=https://godoc.org/go/token#Position>token/Position</a>を使います。</p><p><code>token.Position</code>構造体はファイル名、行番号、カラム位置の情報を持っています。</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>type Position struct {
    Filename string // filename, if any
    Offset   int    // offset, starting at 0
    Line     int    // line number, starting at 1
    Column   int    // column number, starting at 1 (byte count)
}
</code></pre></div><p>なお前回も補足しましたが、ノードの位置情報は<code>token.FileSet</code>を元に相対的に決まります。</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>func</span> <span style=color:#447fcf>main</span>() {
  fset := token.<span style=color:#447fcf>NewFileSet</span>()
  f, _ := parser.<span style=color:#447fcf>ParseFile</span>(fset, <span style=color:#ed9d13>&#34;./example/example.go&#34;</span>, <span style=color:#6ab825;font-weight:700>nil</span>, parser.ImportsOnly)

  <span style=color:#999;font-style:italic>// importされているパッケージのファイル名/行数/カラム数と、パッケージ名を出力する
</span><span style=color:#999;font-style:italic></span>  <span style=color:#999;font-style:italic>// token.Pos()はノードがソースコード上に占める位置を指す
</span><span style=color:#999;font-style:italic></span>  <span style=color:#6ab825;font-weight:700>for</span> _, s := <span style=color:#6ab825;font-weight:700>range</span> f.Imports {
    fmt.<span style=color:#447fcf>Println</span>(fset.<span style=color:#447fcf>Position</span>(s.<span style=color:#447fcf>Pos</span>()), s.Path.Value)
  }
}
</code></pre></div><p>出力結果です。</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>./example/example.go:4:2 &#34;fmt&#34;
./example/example.go:5:2 &#34;time&#34;
</code></pre></div><p>ファイル名と行数などの情報を付与したことで、出力結果がよりわかりやすくなりました。</p><hr><h2 id=抽象構文木astを再帰的にトラバースする>抽象構文木(AST)を再帰的にトラバースする</h2><p>今度は、取得した抽象構文木(AST)のすべてのノードを探索（トラバース）して、再帰的に処理してみます。</p><p>トラバースには<a href=https://godoc.org/go/ast#example-Inspect>ast/Inspect</a>を使います。<code>ast/Inspect</code>は抽象構文木（AST)のノードに対する（深さ優先）探索を行います。</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>func</span> <span style=color:#447fcf>main</span>() {
  fset := token.<span style=color:#447fcf>NewFileSet</span>()
  f, _ := parser.<span style=color:#447fcf>ParseFile</span>(fset, <span style=color:#ed9d13>&#34;./example/example.go&#34;</span>, <span style=color:#6ab825;font-weight:700>nil</span>, <span style=color:#3677a9>0</span>)

  ast.<span style=color:#447fcf>Inspect</span>(f, <span style=color:#6ab825;font-weight:700>func</span>(n ast.Node) <span style=color:#6ab825;font-weight:700>bool</span> {
    <span style=color:#6ab825;font-weight:700>var</span> s <span style=color:#6ab825;font-weight:700>string</span>
    <span style=color:#999;font-style:italic>// 型によって処理を分岐する
</span><span style=color:#999;font-style:italic></span>    <span style=color:#6ab825;font-weight:700>switch</span> x := n.(<span style=color:#6ab825;font-weight:700>type</span>) {
    <span style=color:#6ab825;font-weight:700>case</span> *ast.BasicLit: <span style=color:#999;font-style:italic>// リテラル
</span><span style=color:#999;font-style:italic></span>      s = x.Value
    <span style=color:#6ab825;font-weight:700>case</span> *ast.Ident: <span style=color:#999;font-style:italic>// 識別子名
</span><span style=color:#999;font-style:italic></span>      s = x.Name 
    }
    <span style=color:#6ab825;font-weight:700>if</span> s != <span style=color:#ed9d13>&#34;&#34;</span> {
      fmt.<span style=color:#447fcf>Println</span>(fset.<span style=color:#447fcf>Position</span>(n.<span style=color:#447fcf>Pos</span>()), s)
    }
    <span style=color:#6ab825;font-weight:700>return</span> <span style=color:#6ab825;font-weight:700>true</span>
  })
}
</code></pre></div><p>次のような結果が得られます。</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>./example/example.go:1:9 example
./example/example.go:4:2 &#34;fmt&#34;
./example/example.go:5:2 &#34;time&#34;
./example/example.go:8:6 example
./example/example.go:9:2 fmt
./example/example.go:9:6 Println
./example/example.go:9:14 &#34;Now :&#34;
./example/example.go:9:23 time
./example/example.go:9:28 Now
</code></pre></div><p>example.goのソースコードにおける抽象構文木(AST)のすべてのノードを探索し、リテラルと識別子（パッケージ、関数、フィールドや変数など）の名前のみを取得して、一つずつ位置情報とともに出力しています。</p><hr><h2 id=おわりに>おわりに</h2><p>抽象構文木(AST)を使って、静的解析の実践的な処理を行ってみました。</p><p>なお、この記事は<a href=https://golangtokyo.connpass.com/event/122263/>golang.tokyo #22+Okayama.go/Sendai.go</a>のイベントに参加して書きました。</p><p>イベント当日の講義資料はこちらです。</p><ul><li><a href="https://docs.google.com/presentation/d/13FcaQiFnUBk6xb1cNyNUmEIhqTXYMJAs3oUpxXP5_dM/edit#slide=id.g5475518c10_0_0">A Tour of Static Analysis | by tenntennさん</a></li></ul><p>ハンズオンの時間では、golang.tokyoのコードラボ上の教材を進めている方もたくさんいらっしゃいました。</p><p>これから静的解析を始めてみたい方は、こちらのコードラボから始めてみるのもおすすめです。</p><ul><li><a href=https://golangtokyo.github.io/codelab/find-gophers/>golang.tokyo コードラボ | 静的解析をはじめよう - Gopherをさがせ！</a></li><li><a href=https://golangtokyo.github.io/codelab/first-step-type-check/>型チェックでインターフェースを実装しているか調べよう</a></li></ul></section></article><div class=social><div class=social-inner><a href=https://twitter.com/share class=twitter-share-button data-count=horizontal lang=hja>Tweet</a> <script>!function(a,c,d){var b,e=a.getElementsByTagName(c)[0],f=/^http:/.test(a.location)?'http':'https';a.getElementById(d)||(b=a.createElement(c),b.id=d,b.src=f+'://platform.twitter.com/widgets.js',e.parentNode.insertBefore(b,e))}(document,'script','twitter-wjs')</script><a href=http://b.hatena.ne.jp/entry/ class=hatena-bookmark-button data-hatena-bookmark-layout=simple-balloon title=このエントリーをはてなブックマークに追加><img src=https://b.st-hatena.com/images/entry-button/button-only@2x.png alt=このエントリーをはてなブックマークに追加 width=20 height=20 style=border:none></a><script type=text/javascript src=https://b.st-hatena.com/js/bookmark_button.js async></script>
<a data-pocket-label=pocket data-pocket-count=horizontal class=pocket-btn data-lang=en></a><script type=text/javascript>!function(a,c){var b,d;a.getElementById(c)||(b=a.createElement("script"),b.id=c,b.src="https://widgets.getpocket.com/v1/j/btn.js?v=1",d=a.getElementById(c),a.body.appendChild(b))}(document,"pocket-btn-js")</script></div></div><footer id=footer><div id=social><a class=symbol href=https://www.facebook.com/mom0tomo>circlefacebook</a>
<a class=symbol href=https://github.com/mom0tomo>circlegithub</a>
<a class=symbol href=https://twitter.com/mom0tomo>circletwitterbird</a></div><p class=small>© Copyright 2021 mom0tomo</p></footer></section><script src=https://mom0tomo.github.io/js/jquery-3.3.1.min.js></script><script src=https://mom0tomo.github.io/js/main.js></script><script src=https://mom0tomo.github.io/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script></body></html>